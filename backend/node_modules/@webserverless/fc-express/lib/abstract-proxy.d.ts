/// <reference types="node" />
import { Proxy, Resolver, Context } from './proxy-protocol';
import { Server } from './server';
import * as http from 'http';
export declare abstract class AbstractProxy<T extends Context> implements Proxy<T> {
    protected readonly server: Server;
    constructor(server: Server);
    handle(ctx: T): void;
    protected abstract makeResolver(ctx: T): Resolver;
    protected abstract pipeBody(ctx: T, req: http.ClientRequest): void;
    protected abstract getRequestHeaders(ctx: T): any;
    protected abstract getHttpMethod(ctx: T): string;
    protected abstract getPath(ctx: T): string;
    protected getResponseHeaders(response: http.IncomingMessage): http.IncomingHttpHeaders;
    protected forwardRequestToNodeServer(ctx: T): void;
    protected mapContextToHttpRequest(ctx: T): {
        method: string;
        path: string;
        headers: any;
        socketPath: any;
    };
    protected forwardResponse(response: http.IncomingMessage, resolver: Resolver): void;
    protected clone(json: any): any;
    protected getContentType(params: any): any;
    protected isContentTypeBinaryMimeType(params: any): boolean;
    protected forwardConnectionErrorResponse(error: Error, resolver: Resolver): void;
    protected forwardLibraryErrorResponse(error: Error, resolver: Resolver): void;
}
//# sourceMappingURL=abstract-proxy.d.ts.map