"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var proxy_protocol_1 = require("./proxy-protocol");
var http = require("http");
var isType = require("type-is");
var AbstractProxy = /** @class */ (function () {
    function AbstractProxy(server) {
        this.server = server;
    }
    AbstractProxy.prototype.handle = function (ctx) {
        var _this = this;
        if (this.server.isListening) {
            this.forwardRequestToNodeServer(ctx);
        }
        else {
            this.server.startServer()
                .on('listening', function () {
                _this.forwardRequestToNodeServer(ctx);
            });
        }
    };
    AbstractProxy.prototype.getResponseHeaders = function (response) {
        return response.headers;
    };
    AbstractProxy.prototype.forwardRequestToNodeServer = function (ctx) {
        var _this = this;
        var resolver = this.makeResolver(ctx);
        try {
            var requestOptions = this.mapContextToHttpRequest(ctx);
            var req = http.request(requestOptions, function (response) { return _this.forwardResponse(response, resolver); });
            req.on('error', function (error) { return _this.forwardConnectionErrorResponse(error, resolver); });
            this.pipeBody(ctx, req);
        }
        catch (error) {
            this.forwardLibraryErrorResponse(error, resolver);
        }
    };
    AbstractProxy.prototype.mapContextToHttpRequest = function (ctx) {
        var headers = this.getRequestHeaders(ctx);
        headers[proxy_protocol_1.CONTEXT_HEADER_NAME] = encodeURIComponent(JSON.stringify(ctx.context));
        return {
            method: this.getHttpMethod(ctx),
            path: this.getPath(ctx),
            headers: headers,
            socketPath: this.server.getSocketPath()
            // protocol: `${headers['X-Forwarded-Proto']}:`,
            // host: headers.Host,
            // hostname: headers.Host, // Alias for host
            // port: headers['X-Forwarded-Port']
        };
    };
    AbstractProxy.prototype.forwardResponse = function (response, resolver) {
        var _this = this;
        var buf = [];
        response
            .on('data', function (chunk) { return buf.push(chunk); })
            .on('end', function () {
            var body = Buffer.concat(buf);
            var statusCode = response.statusCode;
            var headers = _this.getResponseHeaders(response);
            var contentType = _this.getContentType({ contentTypeHeader: headers['content-type'] });
            var isBase64Encoded = _this.isContentTypeBinaryMimeType({ contentType: contentType, binaryMimeTypes: _this.server.binaryTypes });
            var successResponse = { statusCode: statusCode, body: body, headers: headers, isBase64Encoded: isBase64Encoded };
            resolver(successResponse);
        });
    };
    AbstractProxy.prototype.clone = function (json) {
        return JSON.parse(JSON.stringify(json));
    };
    AbstractProxy.prototype.getContentType = function (params) {
        // only compare mime type; ignore encoding part
        return params.contentTypeHeader ? params.contentTypeHeader.split(';')[0] : '';
    };
    AbstractProxy.prototype.isContentTypeBinaryMimeType = function (params) {
        return params.binaryMimeTypes.length > 0 && !!isType.is(params.contentType, params.binaryMimeTypes);
    };
    AbstractProxy.prototype.forwardConnectionErrorResponse = function (error, resolver) {
        console.log('ERROR: fc-express connection error');
        console.error(error);
        var errorResponse = {
            statusCode: 502,
            body: '',
            headers: {}
        };
        resolver(errorResponse);
    };
    AbstractProxy.prototype.forwardLibraryErrorResponse = function (error, resolver) {
        console.log('ERROR: fc-express error');
        console.error(error);
        var errorResponse = {
            statusCode: 500,
            body: '',
            headers: {}
        };
        resolver(errorResponse);
    };
    return AbstractProxy;
}());
exports.AbstractProxy = AbstractProxy;
//# sourceMappingURL=abstract-proxy.js.map