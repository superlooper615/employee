"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var http = require("http");
var api_gateway_proxy_1 = require("./api-gateway-proxy");
var http_trigger_proxy_1 = require("./http-trigger-proxy");
var Server = /** @class */ (function () {
    function Server(requestListener, serverListenCallback, binaryTypes) {
        var _this = this;
        this.isListening = false;
        this.apiGatewayProxy = new api_gateway_proxy_1.ApiGatewayProxy(this);
        this.httpTriggerProxy = new http_trigger_proxy_1.HttpTriggerProxy(this);
        this.rawServer = http.createServer(requestListener);
        // Set the server's timeout to 600 seconds, which is the same as the FC's max timeout.
        this.rawServer.setTimeout(600 * 1000);
        this.socketPathSuffix = this.getRandomString();
        this.binaryTypes = binaryTypes ? binaryTypes.slice() : [];
        this.rawServer.on('listening', function () {
            _this.isListening = true;
            if (serverListenCallback) {
                serverListenCallback();
            }
        });
        this.rawServer.on('close', function () {
            _this.isListening = false;
        }).on('error', function (error) {
            if (error.code === 'EADDRINUSE') {
                console.warn("WARNING: Attempting to listen on socket " + _this.getSocketPath() + ", but it is already in use.\n                 This is likely as a result of a previous invocation error or timeout. Check the logs for the invocation(s) immediately prior to this for root cause,\n                 and consider increasing the timeout and/or cpu/memory allocation if this is purely as a result of a timeout.\n                 fc-express will restart the Node.js server listening on a new port and continue with this request.");
                _this.socketPathSuffix = _this.getRandomString();
                return _this.rawServer.close(function () { return _this.startServer(); });
            }
            else {
                console.log('ERROR: server error');
                console.error(error);
            }
        });
    }
    Server.prototype.proxy = function (event, context, callback) {
        var e = JSON.parse(event);
        this.apiGatewayProxy.handle({ event: e, context: context, callback: callback });
    };
    Server.prototype.httpProxy = function (request, response, context) {
        this.httpTriggerProxy.handle({ request: request, response: response, context: context });
    };
    Server.prototype.startServer = function () {
        return this.rawServer.listen(this.getSocketPath());
    };
    Server.prototype.getRandomString = function () {
        return Math.random().toString(36).substring(2, 10);
    };
    Server.prototype.getSocketPath = function () {
        /* istanbul ignore if */ /* only running tests on Linux; Window support is for local dev only */
        if (/^win/.test(process.platform)) {
            var path = require('path');
            return path.join('\\\\?\\pipe', process.cwd(), "fc-" + this.socketPathSuffix);
        }
        else {
            return "/tmp/fc-" + this.socketPathSuffix + ".sock";
        }
    };
    return Server;
}());
exports.Server = Server;
//# sourceMappingURL=server.js.map