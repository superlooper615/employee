"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var proxy_protocol_1 = require("./proxy-protocol");
var url = require("url");
var abstract_proxy_1 = require("./abstract-proxy");
var binarycase = require('binary-case');
var ApiGatewayProxy = /** @class */ (function (_super) {
    __extends(ApiGatewayProxy, _super);
    function ApiGatewayProxy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ApiGatewayProxy.prototype.getResponseHeaders = function (response) {
        var headers = response.headers;
        // chunked transfer not currently supported by API Gateway
        /* istanbul ignore else */
        if (headers['transfer-encoding'] === 'chunked') {
            delete headers['transfer-encoding'];
        }
        var _loop_1 = function (h) {
            if (headers.hasOwnProperty(h)) {
                var value = headers[h];
                if (Array.isArray(value)) {
                    if (h.toLowerCase() === 'set-cookie') {
                        value.forEach(function (v, i) {
                            headers[binarycase(h, i + 1)] = v;
                        });
                        delete headers[h];
                    }
                    else {
                        headers[h] = value.join(',');
                    }
                }
            }
        };
        // HACK: modifies header casing to get around API Gateway's limitation of not allowing multiple
        // headers with the same name, as discussed on the AWS Forum https://forums.aws.amazon.com/message.jspa?messageID=725953#725953
        for (var h in headers) {
            _loop_1(h);
        }
        return headers;
    };
    ApiGatewayProxy.prototype.pipeBody = function (ctx, req) {
        var body = this.getBody(ctx);
        if (body) {
            req.write(body);
        }
        req.end();
    };
    ApiGatewayProxy.prototype.getBody = function (ctx) {
        var event = ctx.event;
        if (event.body) {
            return Buffer.from(event.body, event.isBase64Encoded ? 'base64' : 'utf8');
        }
    };
    ApiGatewayProxy.prototype.getRequestHeaders = function (ctx) {
        var event = ctx.event;
        var headers = Object.assign({}, event.headers);
        // NOTE: API Gateway is not setting Content-Length header on requests even when they have a body
        if (event.body && !headers['Content-Length']) {
            var body = this.getBody(ctx);
            if (body) {
                headers['Content-Length'] = body ? Buffer.byteLength(body) : 0;
            }
        }
        var clonedEventWithoutBody = this.clone(event);
        delete clonedEventWithoutBody.body;
        headers[proxy_protocol_1.EVENT_HEADER_NAME] = encodeURIComponent(JSON.stringify(clonedEventWithoutBody));
        return headers;
    };
    ApiGatewayProxy.prototype.getHttpMethod = function (ctx) {
        return ctx.event.httpMethod;
    };
    ApiGatewayProxy.prototype.getPath = function (ctx) {
        var event = ctx.event;
        return url.format({ pathname: event.path, query: event.queryParameters });
    };
    ApiGatewayProxy.prototype.makeResolver = function (ctx) {
        return function (data) {
            data.body = data.body.toString(data.isBase64Encoded ? 'base64' : 'utf8');
            ctx.callback(undefined, data);
        };
    };
    return ApiGatewayProxy;
}(abstract_proxy_1.AbstractProxy));
exports.ApiGatewayProxy = ApiGatewayProxy;
//# sourceMappingURL=api-gateway-proxy.js.map